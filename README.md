# Week3_Challenge
 Study Unity


### Q1. 숙련 1강 ~ 숙련 3강

**분석 문제** : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.
SendMessage에서 Invoke Unity Event로 바뀜.
-> Action이름에 On을 붙여서 입력처리를 하던 SendMessage와 달리, 원하는 메서드명을 작성하여 입력처리 함수를 작성할 수 있음. 그리고 여러개의 메서드를 달아서 입력 시 여러 메서드를 호출할 수도 있음.

- `CharacterManager`와 `Player`의 역할에 대해 고민해보세요.
Player는 게임 내의 Player의 모든 역할이 모여있는 총 집합체 같은 느낌으로 전체적인 Player의 기능들과 필드들을 응집시켜 놓은 것이다. Player가 가질만한 변수와 메서드들은 Player를 통해 대부분 얻을 수 있다. 
CharacterManager는 Player를 전역적으로 관리하기 위해 사용하는 싱글톤이다.

- 핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`)
Move: Vector2로 받은 입력을 Vector3로 바꿔서 rigidbody.veloctity에 속도를 넣어줜다.
CameraLook: 마우스 위치를 받아와서 위치와 민감도만큼 카메라의 각도를 돌려준다.
그런데, 이제  위 아래로 움직이는 화면은 카메라의 각도를 회전시켜 바꿔주고, 왼쪽과 오른쪽으로 움직이는 화면은 이 오브젝트(Player)의 각도를 회전시켜서 바꿔준다.
IsGrounded: 이 오브젝트(Player)가 땅에 닿았는지? 를 bool값으로 반환해준다. 이 오브젝트의 왼, 오, 앞, 뒤 방향의 일정거리에서 아래로 발사하는 Ray를 만들어서 Raycast를 통해 groundLayerMask와 부딪치면 true를 반환, 아니면 false를 반환해주는 역할을 한다.
이 메서드는 Player가 바닥에 닿지 않으면 점프를 할 수 없게 만드는 메서드에서 사용한다.

- `Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.
Move는 물리적인 움직임을 구현하는 코드이기 때문에 물리 업데이트인 FixedUpdate`에서 호출해준다. (근데 왜 물리 업데이트가 따로 있는가?에 대해서 알아봐야 할 듯하다.)
Update 이후의 처리가 필요할 때, LateUpdate를 사용한다. 특정 오브젝트를 따라다니는 카메라 처리는 오브젝트의 위치가 변한 후 처리해주는 것이 좋기 때문에 LateUpdate`에서 구현하면 지연없는 처리를 할 수 있다. (물론 여기에선 그냥 오브젝트에 붙어있는 상황이라 크게 상관없을 것 같긴 하지만)

**확장 문제** : 강의 내용을 바탕으로 새로운 기능을 추가 구현해봅시다.

- 새로운 입력 값을 받아 환경설정 창을 만들어보세요.
- 설정창이 떴을 때 마우스 커서가 보이고 카메라 회전을 막는 기능을 코드로 구현해보세요.

> Menu창 만듬

**개선 문제** : 기존의 코드를 개선해봅시다.

- 새로운 입력 값을 받아 이동 기능에 새로운 옵션을 추가해보세요.

> Run기능 만듬
  
